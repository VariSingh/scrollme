!function(dataAndEvents, definition) {
  if ("function" == typeof define && define.amd) {
    define(definition);
  } else {
    if ("object" == typeof exports) {
      module.exports = definition();
    } else {
      dataAndEvents.ScrollMagic = definition();
    }
  }
}(this, function() {
  /**
   * @return {undefined}
   */
  var exports = function() {
  };
  /** @type {string} */
  exports.version = "2.0.5";
  window.addEventListener("mousewheel", function() {
  });
  /** @type {string} */
  var i = "data-scrollmagic-pin-spacer";
  /**
   * @param {?} settings
   * @return {?}
   */
  exports.Controller = function(settings) {
    var originalEvent;
    var timeoutTimer;
    /** @type {string} */
    var a = "ScrollMagic.Controller";
    /** @type {string} */
    var next = "FORWARD";
    /** @type {string} */
    var doc = "REVERSE";
    /** @type {string} */
    var global = "PAUSED";
    var defaults = config.defaults;
    var self = this;
    var options = $.extend({}, defaults, settings);
    /** @type {Array} */
    var arr = [];
    /** @type {boolean} */
    var result = false;
    /** @type {number} */
    var num = 0;
    /** @type {string} */
    var root = global;
    /** @type {boolean} */
    var isDocument = true;
    /** @type {number} */
    var params = 0;
    /** @type {boolean} */
    var node = true;
    /**
     * @return {undefined}
     */
    var init = function() {
      var i;
      for (i in options) {
        if (!defaults.hasOwnProperty(i)) {
          delete options[i];
        }
      }
      if (options.container = $.get.elements(options.container)[0], !options.container) {
        throw a + " init failed.";
      }
      /** @type {boolean} */
      isDocument = options.container === window || (options.container === document.body || !document.body.contains(options.container));
      if (isDocument) {
        /** @type {Window} */
        options.container = window;
      }
      params = extend();
      options.container.addEventListener("resize", resize);
      options.container.addEventListener("scroll", resize);
      /** @type {number} */
      options.refreshInterval = parseInt(options.refreshInterval) || defaults.refreshInterval;
      fix();
    };
    /**
     * @return {undefined}
     */
    var fix = function() {
      if (options.refreshInterval > 0) {
        /** @type {number} */
        timeoutTimer = window.setTimeout(handler, options.refreshInterval);
      }
    };
    /**
     * @return {?}
     */
    var bind = function() {
      return options.vertical ? $.get.scrollTop(options.container) : $.get.scrollLeft(options.container);
    };
    /**
     * @return {?}
     */
    var extend = function() {
      return options.vertical ? $.get.height(options.container) : $.get.width(options.container);
    };
    /** @type {function (number): undefined} */
    var callback = this._setScrollPos = function(val) {
      if (options.vertical) {
        if (isDocument) {
          window.scrollTo($.get.scrollLeft(), val);
        } else {
          /** @type {number} */
          options.container.scrollTop = val;
        }
      } else {
        if (isDocument) {
          window.scrollTo(val, $.get.scrollTop());
        } else {
          /** @type {number} */
          options.container.scrollLeft = val;
        }
      }
    };
    /**
     * @return {undefined}
     */
    var parse = function() {
      if (node && result) {
        var matched = $.type.Array(result) ? result : arr.slice(0);
        /** @type {boolean} */
        result = false;
        var i = num;
        num = self.scrollPos();
        /** @type {number} */
        var pos = num - i;
        if (0 !== pos) {
          /** @type {string} */
          root = pos > 0 ? next : doc;
        }
        if (root === doc) {
          matched.reverse();
        }
        matched.forEach(function(vec) {
          vec.update(true);
        });
      }
    };
    /**
     * @return {undefined}
     */
    var requestAnimationFrame = function() {
      originalEvent = $.rAF(parse);
    };
    /**
     * @param {Event} event
     * @return {undefined}
     */
    var resize = function(event) {
      if ("resize" == event.type) {
        params = extend();
        /** @type {string} */
        root = global;
      }
      if (result !== true) {
        /** @type {boolean} */
        result = true;
        requestAnimationFrame();
      }
    };
    /**
     * @return {undefined}
     */
    var handler = function() {
      if (!isDocument && params != extend()) {
        var event;
        try {
          /** @type {Event} */
          event = new Event("resize", {
            bubbles : false,
            cancelable : false
          });
        } catch (t) {
          /** @type {(Event|null)} */
          event = document.createEvent("Event");
          event.initEvent("resize", false, false);
        }
        options.container.dispatchEvent(event);
      }
      arr.forEach(function(target) {
        target.refresh();
      });
      fix();
    };
    this._options = options;
    /**
     * @param {Object} arr
     * @return {?}
     */
    var sortByProcedure = function(arr) {
      if (arr.length <= 1) {
        return arr;
      }
      var bProperties = arr.slice(0);
      return bProperties.sort(function(dataAndEvents, adapter) {
        return dataAndEvents.scrollOffset() > adapter.scrollOffset() ? 1 : -1;
      }), bProperties;
    };
    return this.addScene = function(object) {
      if ($.type.Array(object)) {
        object.forEach(function(which) {
          self.addScene(which);
        });
      } else {
        if (object instanceof exports.Scene) {
          if (object.controller() !== self) {
            object.addTo(self);
          } else {
            if (arr.indexOf(object) < 0) {
              arr.push(object);
              arr = sortByProcedure(arr);
              object.on("shift.controller_sort", function() {
                arr = sortByProcedure(arr);
              });
              var key;
              for (key in options.globalSceneOptions) {
                if (object[key]) {
                  object[key].call(object, options.globalSceneOptions[key]);
                }
              }
            }
          }
        }
      }
      return self;
    }, this.removeScene = function(item) {
      if ($.type.Array(item)) {
        item.forEach(function(isSorted) {
          self.removeScene(isSorted);
        });
      } else {
        var index = arr.indexOf(item);
        if (index > -1) {
          item.off("shift.controller_sort");
          arr.splice(index, 1);
          item.remove();
        }
      }
      return self;
    }, this.updateScene = function(object, recurring) {
      return $.type.Array(object) ? object.forEach(function(which) {
        self.updateScene(which, recurring);
      }) : recurring ? object.update(true) : result !== true && (object instanceof exports.Scene && (result = result || [], -1 == result.indexOf(object) && result.push(object), result = sortByProcedure(result), requestAnimationFrame())), self;
    }, this.update = function(dataAndEvents) {
      return resize({
        type : "resize"
      }), dataAndEvents && parse(), self;
    }, this.scrollTo = function(node, value) {
      if ($.type.Number(node)) {
        callback.call(options.container, node, value);
      } else {
        if (node instanceof exports.Scene) {
          if (node.controller() === self) {
            self.scrollTo(node.scrollOffset(), value);
          }
        } else {
          if ($.type.Function(node)) {
            /** @type {Object} */
            callback = node;
          } else {
            var target = $.get.elements(node)[0];
            if (target) {
              for (;target.parentNode.hasAttribute(i);) {
                target = target.parentNode;
              }
              /** @type {string} */
              var prop = options.vertical ? "top" : "left";
              var prev = $.get.offset(options.container);
              var next = $.get.offset(target);
              if (!isDocument) {
                prev[prop] -= self.scrollPos();
              }
              self.scrollTo(next[prop] - prev[prop], value);
            }
          }
        }
      }
      return self;
    }, this.scrollPos = function(walkers) {
      return arguments.length ? ($.type.Function(walkers) && (bind = walkers), self) : bind.call(self);
    }, this.info = function(name) {
      var data = {
        size : params,
        vertical : options.vertical,
        scrollPos : num,
        scrollDirection : root,
        container : options.container,
        isDocument : isDocument
      };
      return arguments.length ? void 0 !== data[name] ? data[name] : void 0 : data;
    }, this.loglevel = function() {
      return self;
    }, this.enabled = function(root) {
      return arguments.length ? (node != root && (node = !!root, self.updateScene(arr, true)), self) : node;
    }, this.destroy = function(async) {
      window.clearTimeout(timeoutTimer);
      var arrCount = arr.length;
      for (;arrCount--;) {
        arr[arrCount].destroy(async);
      }
      return options.container.removeEventListener("resize", resize), options.container.removeEventListener("scroll", resize), $.cAF(originalEvent), null;
    }, init(), self;
  };
  var config = {
    defaults : {
      container : window,
      vertical : true,
      globalSceneOptions : {},
      loglevel : 2,
      refreshInterval : 100
    }
  };
  /**
   * @param {?} option
   * @param {?} value
   * @return {undefined}
   */
  exports.Controller.addOption = function(option, value) {
    config.defaults[option] = value;
  };
  /**
   * @param {Function} opt_attributes
   * @return {undefined}
   */
  exports.Controller.extend = function(opt_attributes) {
    var base = this;
    /**
     * @return {?}
     */
    exports.Controller = function() {
      return base.apply(this, arguments), this.$super = $.extend({}, this), opt_attributes.apply(this, arguments) || this;
    };
    $.extend(exports.Controller, base);
    exports.Controller.prototype = base.prototype;
    /** @type {function (): ?} */
    exports.Controller.prototype.constructor = exports.Controller;
  };
  /**
   * @param {?} opts
   * @return {?}
   */
  exports.Scene = function(opts) {
    var fn;
    var that;
    /** @type {string} */
    var WAITING = "BEFORE";
    /** @type {string} */
    var state = "DURING";
    /** @type {string} */
    var CLOSED = "AFTER";
    var defaults = t.defaults;
    var self = this;
    var config = $.extend({}, defaults, opts);
    /** @type {string} */
    var currentState = WAITING;
    /** @type {number} */
    var scale = 0;
    var params = {
      start : 0,
      end : 0
    };
    /** @type {number} */
    var dest = 0;
    /** @type {boolean} */
    var list = true;
    /**
     * @return {undefined}
     */
    var draw = function() {
      var i;
      for (i in config) {
        if (!defaults.hasOwnProperty(i)) {
          delete config[i];
        }
      }
      var failuresLink;
      for (failuresLink in defaults) {
        on(failuresLink);
      }
      destroy();
    };
    var c = {};
    /**
     * @param {?} eventName
     * @param {Function} func
     * @return {?}
     */
    this.on = function(eventName, func) {
      return $.type.Function(func) && (eventName = eventName.trim().split(" "), eventName.forEach(function(pair) {
        var match = pair.split(".");
        var ext = match[0];
        var eventName = match[1];
        if ("*" != ext) {
          if (!c[ext]) {
            /** @type {Array} */
            c[ext] = [];
          }
          c[ext].push({
            namespace : eventName || "",
            /** @type {Function} */
            callback : func
          });
        }
      })), self;
    };
    /**
     * @param {?} e
     * @param {Function} x
     * @return {?}
     */
    this.off = function(e, x) {
      return e ? (e = e.trim().split(" "), e.forEach(function(pair) {
        var segmentMatch = pair.split(".");
        var key = segmentMatch[0];
        var value = segmentMatch[1] || "";
        /** @type {Array} */
        var asserterNames = "*" === key ? Object.keys(c) : [key];
        asserterNames.forEach(function(eventName) {
          var fns = c[eventName] || [];
          var i = fns.length;
          for (;i--;) {
            var that = fns[i];
            if (!!that) {
              if (!(value !== that.namespace && "*" !== value)) {
                if (!(x && x != that.callback)) {
                  fns.splice(i, 1);
                }
              }
            }
          }
          if (!fns.length) {
            delete c[eventName];
          }
        });
      }), self) : self;
    };
    /**
     * @param {string} name
     * @param {?} opt_attributes
     * @return {?}
     */
    this.trigger = function(name, opt_attributes) {
      if (name) {
        var dom = name.trim().split(".");
        var e = dom[0];
        var p = dom[1];
        var left = c[e];
        if (left) {
          left.forEach(function(event) {
            if (!(p && p !== event.namespace)) {
              event.callback.call(self, new exports.Event(e, event.namespace, self, opt_attributes));
            }
          });
        }
      }
      return self;
    };
    self.on("change.internal", function(_arg) {
      if ("loglevel" !== _arg.what) {
        if ("tweenChanges" !== _arg.what) {
          if ("triggerElement" === _arg.what) {
            load();
          } else {
            if ("reverse" === _arg.what) {
              self.update();
            }
          }
        }
      }
    }).on("shift.internal", function() {
      show();
      self.update();
    });
    /**
     * @param {string} game
     * @return {?}
     */
    this.addTo = function(game) {
      return game instanceof exports.Controller && (that != game && (that && that.removeScene(self), that = game, destroy(), update(true), load(true), show(), that.info("container").addEventListener("resize", mouseup), game.addScene(self), self.trigger("add", {
        controller : that
      }), self.update())), self;
    };
    /**
     * @param {?} root
     * @return {?}
     */
    this.enabled = function(root) {
      return arguments.length ? (list != root && (list = !!root, self.update(true)), self) : list;
    };
    /**
     * @return {?}
     */
    this.remove = function() {
      if (that) {
        that.info("container").removeEventListener("resize", mouseup);
        var game = that;
        that = void 0;
        game.removeScene(self);
        self.trigger("remove");
      }
      return self;
    };
    /**
     * @param {?} async
     * @return {?}
     */
    this.destroy = function(async) {
      return self.trigger("destroy", {
        reset : async
      }), self.remove(), self.off("*.*"), null;
    };
    /**
     * @param {boolean} dataAndEvents
     * @return {?}
     */
    this.update = function(dataAndEvents) {
      if (that) {
        if (dataAndEvents) {
          if (that.enabled() && list) {
            var progress;
            var i = that.info("scrollPos");
            /** @type {number} */
            progress = config.duration > 0 ? (i - params.start) / (params.end - params.start) : i >= params.start ? 1 : 0;
            self.trigger("update", {
              startPos : params.start,
              endPos : params.end,
              scrollPos : i
            });
            self.progress(progress);
          } else {
            if (node) {
              if (currentState === state) {
                start(true);
              }
            }
          }
        } else {
          that.updateScene(self, false);
        }
      }
      return self;
    };
    /**
     * @return {?}
     */
    this.refresh = function() {
      return update(), load(), self;
    };
    /**
     * @param {number} value
     * @return {?}
     */
    this.progress = function(value) {
      if (arguments.length) {
        /** @type {boolean} */
        var modify = false;
        var length = currentState;
        var scrollDirection = that ? that.info("scrollDirection") : "PAUSED";
        var _powerSaveEnabled = config.reverse || value >= scale;
        if (0 === config.duration ? (modify = scale != value, scale = 1 > value && _powerSaveEnabled ? 0 : 1, currentState = 0 === scale ? WAITING : state) : 0 > value && (currentState !== WAITING && _powerSaveEnabled) ? (scale = 0, currentState = WAITING, modify = true) : value >= 0 && (1 > value && _powerSaveEnabled) ? (scale = value, currentState = state, modify = true) : value >= 1 && currentState !== CLOSED ? (scale = 1, currentState = CLOSED, modify = true) : currentState !== state || (_powerSaveEnabled || 
        start()), modify) {
          var data = {
            progress : scale,
            state : currentState,
            scrollDirection : scrollDirection
          };
          /** @type {boolean} */
          var u = currentState != length;
          /**
           * @param {string} type
           * @return {undefined}
           */
          var animate = function(type) {
            self.trigger(type, data);
          };
          if (u) {
            if (length !== state) {
              animate("enter");
              animate(length === WAITING ? "start" : "end");
            }
          }
          animate("progress");
          if (u) {
            if (currentState !== state) {
              animate(currentState === WAITING ? "start" : "end");
              animate("leave");
            }
          }
        }
        return self;
      }
      return scale;
    };
    /**
     * @return {undefined}
     */
    var show = function() {
      params = {
        start : dest + config.offset
      };
      if (that) {
        if (config.triggerElement) {
          params.start -= that.info("size") * config.triggerHook;
        }
      }
      params.end = params.start + config.duration;
    };
    /**
     * @param {boolean} dataAndEvents
     * @return {undefined}
     */
    var update = function(dataAndEvents) {
      if (fn) {
        /** @type {string} */
        var type = "duration";
        if (Event(type, fn.call(self))) {
          if (!dataAndEvents) {
            self.trigger("change", {
              what : type,
              newval : config[type]
            });
            self.trigger("shift", {
              reason : type
            });
          }
        }
      }
    };
    /**
     * @param {boolean} dataAndEvents
     * @return {undefined}
     */
    var load = function(dataAndEvents) {
      /** @type {number} */
      var mat = 0;
      var node = config.triggerElement;
      if (that && node) {
        var o = that.info();
        var origin = $.get.offset(o.container);
        /** @type {string} */
        var prop = o.vertical ? "top" : "left";
        for (;node.parentNode.hasAttribute(i);) {
          node = node.parentNode;
        }
        var target = $.get.offset(node);
        if (!o.isDocument) {
          origin[prop] -= that.scrollPos();
        }
        /** @type {number} */
        mat = target[prop] - origin[prop];
      }
      /** @type {boolean} */
      var u = mat != dest;
      /** @type {number} */
      dest = mat;
      if (u) {
        if (!dataAndEvents) {
          self.trigger("shift", {
            reason : "triggerElementPosition"
          });
        }
      }
    };
    /**
     * @return {undefined}
     */
    var mouseup = function() {
      if (config.triggerHook > 0) {
        self.trigger("shift", {
          reason : "containerResize"
        });
      }
    };
    var obj = $.extend(t.validate, {
      /**
       * @param {Object} duration
       * @return {?}
       */
      duration : function(duration) {
        if ($.type.String(duration) && duration.match(/^(\.|\d)*\d+%$/)) {
          /** @type {number} */
          var size = parseFloat(duration) / 100;
          /**
           * @return {?}
           */
          duration = function() {
            return that ? that.info("size") * size : 0;
          };
        }
        if ($.type.Function(duration)) {
          /** @type {Object} */
          fn = duration;
          try {
            /** @type {number} */
            duration = parseFloat(fn());
          } catch (t) {
            /** @type {number} */
            duration = -1;
          }
        }
        if (duration = parseFloat(duration), !$.type.Number(duration) || 0 > duration) {
          throw fn ? (fn = void 0, 0) : 0;
        }
        return duration;
      }
    });
    /**
     * @param {Object} name
     * @return {undefined}
     */
    var destroy = function(name) {
      /** @type {Array} */
      name = arguments.length ? [name] : Object.keys(obj);
      name.forEach(function(key) {
        var value;
        if (obj[key]) {
          try {
            value = obj[key](config[key]);
          } catch (n) {
            value = defaults[key];
          } finally {
            config[key] = value;
          }
        }
      });
    };
    /**
     * @param {string} type
     * @param {?} obj
     * @return {?}
     */
    var Event = function(type, obj) {
      /** @type {boolean} */
      var tracking = false;
      var value = config[type];
      return config[type] != obj && (config[type] = obj, destroy(type), tracking = value != config[type]), tracking;
    };
    /**
     * @param {string} type
     * @return {undefined}
     */
    var on = function(type) {
      if (!self[type]) {
        /**
         * @param {?} walkers
         * @return {?}
         */
        self[type] = function(walkers) {
          return arguments.length ? ("duration" === type && (fn = void 0), Event(type, walkers) && (self.trigger("change", {
            what : type,
            newval : config[type]
          }), t.shifts.indexOf(type) > -1 && self.trigger("shift", {
            reason : type
          })), self) : config[type];
        };
      }
    };
    /**
     * @return {?}
     */
    this.controller = function() {
      return that;
    };
    /**
     * @return {?}
     */
    this.state = function() {
      return currentState;
    };
    /**
     * @return {?}
     */
    this.scrollOffset = function() {
      return params.start;
    };
    /**
     * @return {?}
     */
    this.triggerPosition = function() {
      var offset = config.offset;
      return that && (offset += config.triggerElement ? dest : that.info("size") * self.triggerHook()), offset;
    };
    var node;
    var options;
    self.on("shift.internal", function(err) {
      /** @type {boolean} */
      var duration = "duration" === err.reason;
      if (currentState === CLOSED && duration || currentState === state && 0 === config.duration) {
        start();
      }
      if (duration) {
        init();
      }
    }).on("progress.internal", function() {
      start();
    }).on("add.internal", function() {
      init();
    }).on("destroy.internal", function(record) {
      self.removePin(record.reset);
    });
    /**
     * @param {boolean} dataAndEvents
     * @return {undefined}
     */
    var start = function(dataAndEvents) {
      if (node && that) {
        var settings = that.info();
        var textarea = options.spacer.firstChild;
        if (dataAndEvents || currentState !== state) {
          var style = {
            position : options.inFlow ? "relative" : "absolute",
            top : 0,
            left : 0
          };
          /** @type {boolean} */
          var o = $.css(textarea, "position") != style.position;
          if (options.pushFollowers) {
            if (config.duration > 0) {
              if (currentState === CLOSED && 0 === parseFloat($.css(options.spacer, "padding-top"))) {
                /** @type {boolean} */
                o = true;
              } else {
                if (currentState === WAITING) {
                  if (0 === parseFloat($.css(options.spacer, "padding-bottom"))) {
                    /** @type {boolean} */
                    o = true;
                  }
                }
              }
            }
          } else {
            /** @type {number} */
            style[settings.vertical ? "top" : "left"] = config.duration * scale;
          }
          $.css(textarea, style);
          if (o) {
            init();
          }
        } else {
          if ("fixed" != $.css(textarea, "position")) {
            $.css(textarea, {
              position : "fixed"
            });
            init();
          }
          var pos = $.get.offset(options.spacer, true);
          /** @type {number} */
          var trunkLen = config.reverse || 0 === config.duration ? settings.scrollPos - params.start : Math.round(scale * config.duration * 10) / 10;
          pos[settings.vertical ? "top" : "left"] += trunkLen;
          $.css(options.spacer.firstChild, {
            top : pos.top,
            left : pos.left
          });
        }
      }
    };
    /**
     * @return {undefined}
     */
    var init = function() {
      if (node && (that && options.inFlow)) {
        /** @type {boolean} */
        var layer = currentState === state;
        var reverse = that.info("vertical");
        var start = options.spacer.firstChild;
        var height = $.isMarginCollapseType($.css(options.spacer, "display"));
        var style = {};
        if (options.relSize.width || options.relSize.autoFullWidth) {
          if (layer) {
            $.css(node, {
              width : $.get.width(options.spacer)
            });
          } else {
            $.css(node, {
              width : "100%"
            });
          }
        } else {
          style["min-width"] = $.get.width(reverse ? node : start, true, true);
          style.width = layer ? style["min-width"] : "auto";
        }
        if (options.relSize.height) {
          if (layer) {
            $.css(node, {
              height : $.get.height(options.spacer) - (options.pushFollowers ? config.duration : 0)
            });
          } else {
            $.css(node, {
              height : "100%"
            });
          }
        } else {
          style["min-height"] = $.get.height(reverse ? start : node, true, !height);
          style.height = layer ? style["min-height"] : "auto";
        }
        if (options.pushFollowers) {
          /** @type {number} */
          style["padding" + (reverse ? "Top" : "Left")] = config.duration * scale;
          /** @type {number} */
          style["padding" + (reverse ? "Bottom" : "Right")] = config.duration * (1 - scale);
        }
        $.css(options.spacer, style);
      }
    };
    /**
     * @return {undefined}
     */
    var completed = function() {
      if (that) {
        if (node) {
          if (currentState === state) {
            if (!that.info("isDocument")) {
              start();
            }
          }
        }
      }
    };
    /**
     * @return {undefined}
     */
    var onWindowResize = function() {
      if (that) {
        if (node) {
          if (currentState === state) {
            if ((options.relSize.width || options.relSize.autoFullWidth) && $.get.width(window) != $.get.width(options.spacer.parentNode) || options.relSize.height && $.get.height(window) != $.get.height(options.spacer.parentNode)) {
              init();
            }
          }
        }
      }
    };
    /**
     * @param {Object} event
     * @return {undefined}
     */
    var handler = function(event) {
      if (that) {
        if (node) {
          if (currentState === state) {
            if (!that.info("isDocument")) {
              event.preventDefault();
              that._setScrollPos(that.info("scrollPos") - ((event.wheelDelta || event[that.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || 30 * -event.detail));
            }
          }
        }
      }
    };
    /**
     * @param {string} parent
     * @param {Text} vars
     * @return {?}
     */
    this.setPin = function(parent, vars) {
      var defaults = {
        pushFollowers : true,
        spacerClass : "scrollmagic-pin-spacer"
      };
      if (vars = $.extend({}, defaults, vars), parent = $.get.elements(parent)[0], !parent) {
        return self;
      }
      if ("fixed" === $.css(parent, "position")) {
        return self;
      }
      if (node) {
        if (node === parent) {
          return self;
        }
        self.removePin();
      }
      /** @type {string} */
      node = parent;
      var gutterDisplay = node.parentNode.style.display;
      /** @type {Array} */
      var directions = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
      /** @type {string} */
      node.parentNode.style.display = "none";
      /** @type {boolean} */
      var _mustShow = "absolute" != $.css(node, "position");
      var attributes = $.css(node, directions.concat(["display"]));
      var file = $.css(node, ["width", "height"]);
      node.parentNode.style.display = gutterDisplay;
      if (!_mustShow) {
        if (vars.pushFollowers) {
          /** @type {boolean} */
          vars.pushFollowers = false;
        }
      }
      var div = node.parentNode.insertBefore(document.createElement("div"), node);
      var keys = $.extend(attributes, {
        position : _mustShow ? "relative" : "absolute",
        boxSizing : "content-box",
        mozBoxSizing : "content-box",
        webkitBoxSizing : "content-box"
      });
      if (_mustShow || $.extend(keys, $.css(node, ["width", "height"])), $.css(div, keys), div.setAttribute(i, ""), $.addClass(div, vars.spacerClass), options = {
        spacer : div,
        relSize : {
          width : "%" === file.width.slice(-1),
          height : "%" === file.height.slice(-1),
          autoFullWidth : "auto" === file.width && (_mustShow && $.isMarginCollapseType(attributes.display))
        },
        pushFollowers : vars.pushFollowers,
        inFlow : _mustShow
      }, !node.___origStyle) {
        node.___origStyle = {};
        var s = node.style;
        /** @type {Array} */
        var asserterNames = directions.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]);
        asserterNames.forEach(function(prop) {
          node.___origStyle[prop] = s[prop] || "";
        });
      }
      return options.relSize.width && $.css(div, {
        width : file.width
      }), options.relSize.height && $.css(div, {
        height : file.height
      }), div.appendChild(node), $.css(node, {
        position : _mustShow ? "relative" : "absolute",
        margin : "auto",
        top : "auto",
        left : "auto",
        bottom : "auto",
        right : "auto"
      }), (options.relSize.width || options.relSize.autoFullWidth) && $.css(node, {
        boxSizing : "border-box",
        mozBoxSizing : "border-box",
        webkitBoxSizing : "border-box"
      }), window.addEventListener("scroll", completed), window.addEventListener("resize", completed), window.addEventListener("resize", onWindowResize), node.addEventListener("mousewheel", handler), node.addEventListener("DOMMouseScroll", handler), start(), self;
    };
    /**
     * @param {boolean} reset
     * @return {?}
     */
    this.removePin = function(reset) {
      if (node) {
        if (currentState === state && start(true), reset || !that) {
          var elem = options.spacer.firstChild;
          if (elem.hasAttribute(i)) {
            var elemStyle = options.spacer.style;
            /** @type {Array} */
            var asserterNames = ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
            margins = {};
            asserterNames.forEach(function(key) {
              margins[key] = elemStyle[key] || "";
            });
            $.css(elem, margins);
          }
          options.spacer.parentNode.insertBefore(elem, options.spacer);
          options.spacer.parentNode.removeChild(options.spacer);
          if (!node.parentNode.hasAttribute(i)) {
            $.css(node, node.___origStyle);
            delete node.___origStyle;
          }
        }
        window.removeEventListener("scroll", completed);
        window.removeEventListener("resize", completed);
        window.removeEventListener("resize", onWindowResize);
        node.removeEventListener("mousewheel", handler);
        node.removeEventListener("DOMMouseScroll", handler);
        node = void 0;
      }
      return self;
    };
    var className;
    /** @type {Array} */
    var data = [];
    return self.on("destroy.internal", function(record) {
      self.removeClassToggle(record.reset);
    }), this.setClassToggle = function(selector, isXML) {
      var tmp = $.get.elements(selector);
      return 0 !== tmp.length && $.type.String(isXML) ? (data.length > 0 && self.removeClassToggle(), className = isXML, data = tmp, self.on("enter.internal_class leave.internal_class", function(event) {
        var animateClose = "enter" === event.type ? $.addClass : $.removeClass;
        data.forEach(function(element) {
          animateClose(element, className);
        });
      }), self) : self;
    }, this.removeClassToggle = function(dataAndEvents) {
      return dataAndEvents && data.forEach(function(klass) {
        $.removeClass(klass, className);
      }), self.off("start.internal_class end.internal_class"), className = void 0, data = [], self;
    }, draw(), self;
  };
  var t = {
    defaults : {
      duration : 0,
      offset : 0,
      triggerElement : void 0,
      triggerHook : 0.5,
      reverse : true,
      loglevel : 2
    },
    validate : {
      /**
       * @param {(number|string)} pos
       * @return {?}
       */
      offset : function(pos) {
        if (pos = parseFloat(pos), !$.type.Number(pos)) {
          throw 0;
        }
        return pos;
      },
      /**
       * @param {Object} selector
       * @return {?}
       */
      triggerElement : function(selector) {
        if (selector = selector || void 0) {
          var until = $.get.elements(selector)[0];
          if (!until) {
            throw 0;
          }
          selector = until;
        }
        return selector;
      },
      /**
       * @param {(number|string)} m
       * @return {?}
       */
      triggerHook : function(m) {
        var o = {
          onCenter : 0.5,
          onEnter : 1,
          onLeave : 0
        };
        if ($.type.Number(m)) {
          /** @type {number} */
          m = Math.max(0, Math.min(parseFloat(m), 1));
        } else {
          if (!(m in o)) {
            throw 0;
          }
          m = o[m];
        }
        return m;
      },
      /**
       * @param {?} pos
       * @return {?}
       */
      reverse : function(pos) {
        return!!pos;
      }
    },
    shifts : ["duration", "offset", "triggerHook"]
  };
  /**
   * @param {?} key
   * @param {?} value
   * @param {?} val
   * @param {?} selectbox
   * @return {undefined}
   */
  exports.Scene.addOption = function(key, value, val, selectbox) {
    if (!(key in t.defaults)) {
      t.defaults[key] = value;
      t.validate[key] = val;
      if (selectbox) {
        t.shifts.push(key);
      }
    }
  };
  /**
   * @param {Function} opt_attributes
   * @return {undefined}
   */
  exports.Scene.extend = function(opt_attributes) {
    var base = this;
    /**
     * @return {?}
     */
    exports.Scene = function() {
      return base.apply(this, arguments), this.$super = $.extend({}, this), opt_attributes.apply(this, arguments) || this;
    };
    $.extend(exports.Scene, base);
    exports.Scene.prototype = base.prototype;
    /** @type {function (): ?} */
    exports.Scene.prototype.constructor = exports.Scene;
  };
  /**
   * @param {string} type
   * @param {string} opt_target
   * @param {EventTarget} target
   * @param {Object} helper
   * @return {?}
   */
  exports.Event = function(type, opt_target, target, helper) {
    helper = helper || {};
    var key;
    for (key in helper) {
      this[key] = helper[key];
    }
    return this.type = type, this.target = this.currentTarget = target, this.namespace = opt_target || "", this.timeStamp = this.timestamp = Date.now(), this;
  };
  var $ = exports._util = function(win) {
    var i;
    var me = {};
    /**
     * @param {?} val
     * @return {?}
     */
    var toPixel = function(val) {
      return parseFloat(val) || 0;
    };
    /**
     * @param {Object} el
     * @return {?}
     */
    var getComputedStyle = function(el) {
      return el.currentStyle ? el.currentStyle : win.getComputedStyle(el);
    };
    /**
     * @param {string} name
     * @param {Object} element
     * @param {boolean} deepDataAndEvents
     * @param {boolean} dataAndEvents
     * @return {?}
     */
    var log = function(name, element, deepDataAndEvents, dataAndEvents) {
      if (element = element === document ? win : element, element === win) {
        /** @type {boolean} */
        dataAndEvents = false;
      } else {
        if (!$.DomElement(element)) {
          return 0;
        }
      }
      name = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();
      var n = (deepDataAndEvents ? element["offset" + name] || element["outer" + name] : element["client" + name] || element["inner" + name]) || 0;
      if (deepDataAndEvents && dataAndEvents) {
        var style = getComputedStyle(element);
        n += "Height" === name ? toPixel(style.marginTop) + toPixel(style.marginBottom) : toPixel(style.marginLeft) + toPixel(style.marginRight);
      }
      return n;
    };
    /**
     * @param {string} s
     * @return {?}
     */
    var camelize = function(s) {
      return s.replace(/^[^a-z]+([a-z])/g, "$1").replace(/-([a-z])/g, function(m) {
        return m[1].toUpperCase();
      });
    };
    /**
     * @param {Object} obj
     * @return {?}
     */
    me.extend = function(obj) {
      obj = obj || {};
      /** @type {number} */
      i = 1;
      for (;i < arguments.length;i++) {
        if (arguments[i]) {
          var prop;
          for (prop in arguments[i]) {
            if (arguments[i].hasOwnProperty(prop)) {
              obj[prop] = arguments[i][prop];
            }
          }
        }
      }
      return obj;
    };
    /**
     * @param {?} existingFn
     * @return {?}
     */
    me.isMarginCollapseType = function(existingFn) {
      return["block", "flex", "list-item", "table", "-webkit-box"].indexOf(existingFn) > -1;
    };
    /** @type {number} */
    var lastTime = 0;
    /** @type {Array} */
    var vendors = ["ms", "moz", "webkit", "o"];
    /** @type {function (this:Window, function (number): ?, (Element|null)=): number} */
    var raf = win.requestAnimationFrame;
    /** @type {function (this:Window, number): ?} */
    var cancelAnimationFrame = win.cancelAnimationFrame;
    /** @type {number} */
    i = 0;
    for (;!raf && i < vendors.length;++i) {
      raf = win[vendors[i] + "RequestAnimationFrame"];
      cancelAnimationFrame = win[vendors[i] + "CancelAnimationFrame"] || win[vendors[i] + "CancelRequestAnimationFrame"];
    }
    if (!raf) {
      /**
       * @param {?} callback
       * @return {?}
       */
      raf = function(callback) {
        /** @type {number} */
        var currTime = (new Date).getTime();
        /** @type {number} */
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        /** @type {number} */
        var id = win.setTimeout(function() {
          callback(currTime + timeToCall);
        }, timeToCall);
        return lastTime = currTime + timeToCall, id;
      };
    }
    if (!cancelAnimationFrame) {
      /**
       * @param {?} id
       * @return {undefined}
       */
      cancelAnimationFrame = function(id) {
        win.clearTimeout(id);
      };
    }
    me.rAF = raf.bind(win);
    me.cAF = cancelAnimationFrame.bind(win);
    /** @type {function (Function): ?} */
    var $ = me.type = function(obj) {
      return Object.prototype.toString.call(obj).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
    };
    /**
     * @param {Object} value
     * @return {?}
     */
    $.String = function(value) {
      return "string" === $(value);
    };
    /**
     * @param {Function} obj
     * @return {?}
     */
    $.Function = function(obj) {
      return "function" === $(obj);
    };
    /**
     * @param {Object} obj
     * @return {?}
     */
    $.Array = function(obj) {
      return Array.isArray(obj);
    };
    /**
     * @param {string} value
     * @return {?}
     */
    $.Number = function(value) {
      return!$.Array(value) && value - parseFloat(value) + 1 >= 0;
    };
    /**
     * @param {Node} object
     * @return {?}
     */
    $.DomElement = function(object) {
      return "object" == typeof HTMLElement ? object instanceof HTMLElement : object && ("object" == typeof object && (null !== object && (1 === object.nodeType && "string" == typeof object.nodeName)));
    };
    var $this = me.get = {};
    return $this.elements = function(element) {
      /** @type {Array} */
      var result = [];
      if ($.String(element)) {
        try {
          /** @type {NodeList} */
          element = document.querySelectorAll(element);
        } catch (e) {
          return result;
        }
      }
      if ("nodelist" === $(element) || $.Array(element)) {
        /** @type {number} */
        var m = 0;
        var ms = result.length = element.length;
        for (;ms > m;m++) {
          var value = element[m];
          result[m] = $.DomElement(value) ? value : $this.elements(value);
        }
      } else {
        if ($.DomElement(element) || (element === document || element === win)) {
          /** @type {Array} */
          result = [element];
        }
      }
      return result;
    }, $this.scrollTop = function(e) {
      return e && "number" == typeof e.scrollTop ? e.scrollTop : win.pageYOffset || 0;
    }, $this.scrollLeft = function(el) {
      return el && "number" == typeof el.scrollLeft ? el.scrollLeft : win.pageXOffset || 0;
    }, $this.width = function(el, deepDataAndEvents, dataAndEvents) {
      return log("width", el, deepDataAndEvents, dataAndEvents);
    }, $this.height = function(el, deepDataAndEvents, dataAndEvents) {
      return log("height", el, deepDataAndEvents, dataAndEvents);
    }, $this.offset = function(parent, dataAndEvents) {
      var pos = {
        top : 0,
        left : 0
      };
      if (parent && parent.getBoundingClientRect) {
        var box = parent.getBoundingClientRect();
        pos.top = box.top;
        pos.left = box.left;
        if (!dataAndEvents) {
          pos.top += $this.scrollTop();
          pos.left += $this.scrollLeft();
        }
      }
      return pos;
    }, me.addClass = function(element, name) {
      if (name) {
        if (element.classList) {
          element.classList.add(name);
        } else {
          element.className += " " + name;
        }
      }
    }, me.removeClass = function(element, className) {
      if (className) {
        if (element.classList) {
          element.classList.remove(className);
        } else {
          element.className = element.className.replace(RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
        }
      }
    }, me.css = function(el, value) {
      if ($.String(value)) {
        return getComputedStyle(el)[camelize(value)];
      }
      if ($.Array(value)) {
        var to_instance = {};
        var computed = getComputedStyle(el);
        return value.forEach(function(property) {
          to_instance[property] = computed[camelize(property)];
        }), to_instance;
      }
      var p;
      for (p in value) {
        var val = value[p];
        if (val == parseFloat(val)) {
          val += "px";
        }
        el.style[camelize(p)] = val;
      }
    }, me;
  }(window || {});
  return exports;
});
